#!/usr/bin/env node
"use strict";

const fs = require("fs");
const path = require("path");
const { check, parseAndAnalyze, formatDiag, FrontendError } = require("../src/frontend");
const { buildIR, printIR, serializeIR, validateSerializedIR } = require("../src/ir");
const { generateC } = require("../src/c_backend");
const { optimizeIR } = require("../src/optimizer");

function usage() {
  console.error("Usage:");
  console.error("  protoscriptc --check <file.pts>");
  console.error("  protoscriptc --emit-ir <file.pts>");
  console.error("  protoscriptc --emit-ir-json <file.pts> [--opt]");
  console.error("  protoscriptc --validate-ir <file.json>");
  console.error("  protoscriptc --emit-c <file.pts> [--opt]");
  process.exit(2);
}

const args = process.argv.slice(2);
if (args.length < 2 || args.length > 3) usage();

const mode = args[0];
const file = args[1];
const optEnabled = args.includes("--opt");

if (
  mode !== "--check" &&
  mode !== "--emit-ir" &&
  mode !== "--emit-ir-json" &&
  mode !== "--validate-ir" &&
  mode !== "--emit-c"
) {
  console.error("error: unsupported mode");
  process.exit(2);
}

if (mode !== "--emit-c" && mode !== "--emit-ir" && mode !== "--emit-ir-json" && optEnabled) {
  console.error("error: --opt is only valid with --emit-c, --emit-ir or --emit-ir-json");
  process.exit(2);
}

const full = path.resolve(file);
let src = "";
try {
  src = fs.readFileSync(full, "utf8");
} catch (e) {
  console.error(`error: cannot read file '${file}'`);
  process.exit(2);
}

try {
  if (mode === "--validate-ir") {
    const doc = JSON.parse(src);
    const errs = validateSerializedIR(doc);
    if (errs.length > 0) {
      for (const e of errs) console.error(`${file}:1:1 E1001 IR_INVALID: ${e}`);
      process.exit(1);
    }
    process.exit(0);
  }

  if (mode === "--check") {
    const diags = check(file, src);
    if (diags.length > 0) {
      for (const d of diags) console.error(formatDiag(d));
      process.exit(1);
    }
    process.exit(0);
  }

  const { ast, diags } = parseAndAnalyze(file, src);
  if (diags.length > 0) {
    for (const d of diags) console.error(formatDiag(d));
    process.exit(1);
  }
  let ir = buildIR(ast);
  if ((mode === "--emit-c" || mode === "--emit-ir" || mode === "--emit-ir-json") && optEnabled) {
    enforceOptimizationGate();
    ir = optimizeIR(ir);
  }
  if (mode === "--emit-ir") {
    process.stdout.write(printIR(ir));
    process.exit(0);
  }
  if (mode === "--emit-ir-json") {
    process.stdout.write(`${JSON.stringify(serializeIR(ir), null, 2)}\n`);
    process.exit(0);
  }
  process.stdout.write(generateC(ir));
  process.exit(0);
} catch (e) {
  if (e instanceof FrontendError && e.diag) {
    console.error(formatDiag(e.diag));
    process.exit(1);
  }
  console.error(`internal error: ${e && e.message ? e.message : String(e)}`);
  process.exit(1);
}

function enforceOptimizationGate() {
  const repoRoot = path.resolve(__dirname, "..");
  const conformanceStamp = path.join(repoRoot, "tests", ".conformance_passed");
  if (!fs.existsSync(conformanceStamp)) {
    console.error("error: optimization gate closed (missing tests/.conformance_passed).");
    console.error("run full conformance first (no skips).");
    process.exit(2);
  }
  if (process.env.BACKEND_C_STABLE !== "1") {
    console.error("error: optimization gate closed (BACKEND_C_STABLE=1 required).");
    process.exit(2);
  }
}
